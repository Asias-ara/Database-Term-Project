기본키 - Null이 될 수 없다

외래키 : 다른 곳에서는 기본키
 - 외래키가 기본키를 참조한다
 - WORKS_ON -> 두개의 외래키가 기본키의 역할을 한다
 - 참조 관계에 있다


관계형 데이터 모델 : 표로 데이터를 표현한다
 - 릴레이션, 릴레이션을 구성하는 애트리뷰트 로만 구성됨
 - 위 두가지가 표를 의미하기에 표로 표현
 - 하나의 표가 아니라 여러개의 표로 구현

관계제약조건 : 관계형 데이터 모델들이 반드시 지켜야 한다
 - 위반하는 상태가 되었을 경우 : DBMS에서 위반이 발생하지 않도록 조치를 해야한다

엔티티 무결성 제약조건 -> 기본키에는 NULL이 포함될 수 없음
참조 무결성 제약조건 -> 참조관계가 있을 때 참조되는 곳에 값이 있어야한다
			-> ER모델에서 없는 부서가 없도록 관계를 맺도록 하였다. 
			     (그런 느낌이다)
		     -> 외래키에는 NULL이 들어가도 된다(Ex. 소속된 부서가 없다)
			->선택적 참여를 의미, 의무적 참여라면 NULL이 있으면 안된다
도메인 제약조건 -> 애트리뷰트에는 도메인이 있고, 도메인에는 저장될수있는 값의 범위와 타입이 있는데, 그 값을 벗어난 값이 저장되면 안된다
키 제약조건 -> 중복이 있어서는 안된다., 식별자로 사용할꺼다. 슈퍼키/캔디데이트키/프라이머리 키

//------------------
데이터베이스 연산 -> 검색, 삽입, 삭제

검색(조회) : 데이터베이스의 상태 변화가 없음 -> 관계제약조건를 생각할 필요 없음

삽입
 - insert가 일어남 -> 상태가 변화
 - 위반사항이 어떤것이 있을까? (있다면 DBMS는 이것을 체크 해야한다)
	- 도메인 제약조건 : 발생시킬 수 있다.
	- 키 제약조건 : 발생시킬 수 있다. (중복된 키가 존재)
	- 엔티티 제약조건 : 발생시킬 수 있다.(기본키에 NULL이 있을 수 있다)
	- 참조 제약조건 : 발생시킬 수 있다
 - 삽입시에 제약조건 4가지를 모두 확인해야한다.
 - 조치사항 : '거부' 혹은 '위반 사항 알림'

삭제
 - delete가 일어남 -> 상태가 변화
 - 위반사항이 어떤것이 있을까?
	- 도메인 제약조건 : 없다.
	- 키 제약조건 : 없다.
	- 엔티티 제약조건 : 없다
	- 참조 제약조건 : 발생시킬 수 있다.
 - 조치사항 : 삭제를 거부(Ex. 시위), 외래키를 바꾸거나 Null로 변환(Ex. 전과), 참조하는 튜플들 모두 삭제
	(Ex 배경. 과가 삭제된다면 학생들은 어떻게 할까)

갱신
 - 삽입 후 다시 삭제랑 같음
 - 모든 제약조건을 알아봐야 됨


// --------------------------------------------------------------------------------
개념적 설계 단계 -> 논리적 설계 단계 -> 물리적 설계 단계
(논리적 설계 단계 : 개념적 스키마(ER 스키마) -> 논리적 설계 -> 논리적 스키마(관계 데이터베이스 스키마))
	-> 7가지 단계가 존재

ER모델 구성요소 : 엔티이, Relationship, attribute
관계형 데이터 모델 구성요소 : Relation, attribute -> 다치 애트리뷰트 허용 안함

변환 단계
 1. 강한 엔티티 타입
 2. 약한 엔티티 타입
	- 다치 엔트리뷰트만 여기 위의 단계에서 변환이 안된다

 3. 1 : 1
 4. 1 : N
 5. M : N

 6. 3진 관계

 7. 다치 애트리뷰트
// -------------------------------
1. 강한 엔티티 타입과 단일 값 애트리뷰트
 - 모든 릴레이션에는 primary key가 있어야 한다

2. 약한 엔티티 타입과 단일 값 애트리 뷰트
 - 부양가족
 - 종속관계(부모)의 primary key와 자신의 약한 key가 기본키가 된다

3. 1:1 관계 타입
 - 방법 1, 2 : 두개의 릴레이션 중 하나를 선택해서 외래키를 추가하자
 - 방법 3 : 관계를 나타내는 릴레이션을 하나 더 만들자(기본키로는 두 릴레이션 중하나를 가져온다)
 - 방법 4 : 하나의 릴레이션으로 합치기 -> 엔티티 무결성 제약조건을 발생 시킬 수 있음
			-> 선택적 참여가 아닌 의무적 참여일 때 사용 가능(둘 중 선택적 참여를 하는 곳이 키가 된다)

4. 1:N 관계 타입
 - 방법 1 : N쪽에다가 1쪽의 기본키를 외래키로 삽입하는 것
 - 방법 2 : 별도의 릴레이션을 만드는 것(N쪽의 기본키가 여기서의 기본키가 됨)
 
 *순환 관계 타입
	- N쪽에다가 1쪽의 기본키를 외래키로 집어 넣는다

5. M:N 관계 타입
 - 새로운 릴레이션을 만드는 방법말고는 없다
 - 키 애트리뷰트는 양쪽에서 온 기본키 모두를 사용한다

6. 3진 관계 타입
 - 새로운 릴레이션을 만들고 외래키(N에 해당하는)로 온 모든것을 기본키로 사용한다

7. 다치애트리뷰트
 - 관계형 데이터 모델은 다치 애트리뷰트를 허용하지 않는다
 - 새로운 릴레이션으로 표현됨
 - 다치애트리뷰트를 뺀 앤티티와 애트리뷰트로 릴레이션을 만들고,
	다치 애트리뷰트의 애트리뷰트와 기본키를 가지고 릴레이션을 하나 더 만든다

관계형 애트리뷰트 역시 지원을 해주지 않으므로 풀어서 애트리뷰트로 만들면 된다

릴레이션의 숫자가 늘어나지 않는 것이 좋다!!!!!

//----------------------------------------------------------
시험 : 처음부터 ~ 관계모델로 변환까지

지금까지 배운것
 - 물리적 모델 : DBMS가 알아서 해줌
 - 논리적 모델, 개념적 모델(ER모델) -> 우리가 해야됨
 - 관계형 데이터 모델(스키마)
	- 포인터 연산이 없다(힘을 가지고 있음)

질의어 - 관계대수
 - 원하는 데이터를 추출해 내는 작업
 - DBMS가 꺼내주는데 명령을 명확하게 내려주는 것(언어로)
 - 위의 언어를 질의어(Query)라고 명함
 - SQL이라는 질의어가 가장 Powerful함 -> 매우 쉬운 언어
 - 데이터 베이스에서 원하는 데이터를 빼낼 수 있음
 - 3차 과제 예상 : 데이터 베이스에 스키마를 집어 넣고 원하는 데이터를 꺼내오기

대수(aldebra) : 수식
 - 관계대수 : 선언적 언어(관계 해석에 비해 절차적 언어)
	- (절차적 언어 : 원하는 데이터와 질의를 어떻게 수행할 것인도 명시)
	- 사실 선언적 언어이다
 - 관계해석 : 선언적 언어(원하는 데이터만 명시)

관계 대수
 - 릴레이션(집합)을 항으로 가지는 식
 - 관계연산자는 집합에 대한 연산자와 유사

관계 연산자
 - 필수적인 연산자
	- 단항연산자
		- 실렉션
		- 프로젝션
	- 이항 연산자
		- 합집합
		- 차집합
		- 카티션 프로적트(곱집합)
 - 편의를 위해 유도된 연산자
	- 교집합(합집합과 차집합으로 만들 수 있음)
	- 여러 조인들

- 실렉션 : 행, 튜플 -> 내가 원하는 터플들을 골라 새로운 릴레이션을 만드는 것
	시그마c(R) : 주어진 R이라는 릴레이션에서 c라는 조건을 만족하는 터플을 골래 새로운 릴레이션을 만들어라
	결과 릴레이션은 R과 동일한 애트리뷰트들을 가짐
- 프로젝션 : 열, 어트리뷰트 -> 내가 원하는 어트리뷰트들을 골라 새로운 릴레이션을 만드는것
	파이L(R) : 주어진 R이라는 릴레이션에서 L에 표기된 애트리뷰트만 추출함
	결과 릴레이션에 중복이 있을 경우 삭제함
	(ex.질의 : 모든 사원들의 직급을 검색해라)
	(ex.질의 : 모든 사원들의 직급을 검색해라)
 - 실렉션과 프로젝션은 교환법칙이 될수도 안될수도 있다
	- 셀렉션을 먼저 수행해야지 훨신 이득이고 오류도 나지 않는다
//------------------------------------------------------------------
특징
 - 다수의 연산을 결합하여 관계 대수식(질의)을 형성할 수 있다
 - 각 중간 단계의 임시 릴레이션에 이름을 부여할 수 있다.
	ex. R <- 관계식
 - 결과 릴레이션의 애트리뷰트 이름은 재명며 할 수도 있음
	ex. R(Firstname, Lastname, SALART) <- 파이 FNAMS, LANME, SALARY

집합연산
 - 합치기 위해서는 "대응되는 애트리뷰트"가 같아야한다
	- 호환성 : 적어도 도메인은 같아야한다
	- 스키마가 같아야한다
	- 교집합, 차집합도 마찬가지
	- 애트리뷰트 이름은 R1을 따른다
 - 프로젝션을 통해 맞추고 합집합을 수행한다
 - '이거나' -> 합집합, '이면서' -> 교집합

//---------------------------------------------------------------------
카테시안 프로덕트(곱)
 - R1이 n1,R2가 n2개를 가지고 있으면 R<-R1XR2일 때 n1*n2의 개수가 나옴
 - 옳은 릴레이션 만들기
	- 카테시안 프로덕트 -> 셀렉션

관계대수 연산자의 완전 집합 
 - 위에서 만든 5개를 '관계대수 연산자의 완전집합'이라고 부름
 - 모든 질의 언어들은 관계적으로 완전하다

조인
 - 유도된 연산자 (필수 연산자로 표현 가능)
 - 카테시안 프로덕트 -> 셀렉션이랑 같은 역할
 - 셀프 조인
	- 자기가 자기를 조인한다
	- 릴레이셔을 복사해서 한다고 생각

문제
 - 2번 부서나 3번 부서에 근무하는 모든 사원들의 이름과 급여를 검색하라
	파이(이름, 급여)(시그마(DNO=2 or DNO=3)(EMPLOYEE))
 - 개발 부서에서 근무하는 모든 사원들의 이름을 검색하라
	파이(이름)((시그마(DEPTNAME='개발')((시그마(DNO=DEPTNO)((카테시안(EMPLYOEE X DEPARTMENT))))

관계대수의 확장
 - 산술연산이 없음 : +, -, *, /등
 - 정렬기능이 없음
 - 집단함수 : 여러개의 값을 조합해서 하나의 결과물을 내는것(ex. count, 평균)
 - 갱신연산이 없음
 - 무조건적인 중복배제

//----------------------------------------------------------------------
SQL 개요
 - 원하는 바만 명시 -> 사용자에게 편리
 - 장점 : 자연어(영어)에 가까운 구문
 - 대화식 SQL : 사용자가 실제로 터미널에 앉아 직접 SQL작성하면 DB가 반응
 - 내포된 SQL : 특정 프로그래밍 언어와 결합이 되어 프로그램 코드내 DBMS연결하고 질의보내고 질의의 결과를 받을 수 있는
		(호스트 언어 : 프로그래밍 언어)
 - 구성요소 : 데이터 정의어(스키마와 관련된 정의), 데이터 조작어(DB의 상태 : 검색,삽입,삭제), 데이터 제어어(백업, 초기화 등)

데이터 정의어
 - CREATE SCHEMA : (Schemae - DataBase로 생각)
 - CREATE TABLE : 릴레이션 생성이라고 생각(Table - Relation이라고 생각)
 - DROP TABLE : 릴레이션 삭제
 - ALTER TABLE : 릴레이션 스키마를 변경(애트리뷰트 삭제, 추가)

데이터 타입
 - 표 참고

CREATE TABLE
 - 릴레이션 생성
 - 이름, 애트리뷰트, 데이터 유형을 기술
 - UNIQUE : 중복이 있으면 안된다

ALTER TABLE
 - 스키마는 잘 변경이 안된다(비용이 많이 든다)
 - 가능하면 최대한 하지 않는것이 좋음
 - EX) ALTER TABLE EMPLOYEE ADD JOB VARCHAR(12)
 - JOB의 값을 별도로 입력(UPDATE 명령)

CREATE SCHEMA
 - 새로운 데이터베이스 스키마는 스키마의 이름과 함께 기술함
 - CASCADE : 따라가라

참조 무결성 제약조건
 - ON DELETE NO ACTION : 외래키의 참조하는곳이 삭제되면 그냥 두라
 - ON DELETE CASCADE : 외래키의 참조하는곳이 삭제되면 따라가라(같이 삭제되라)
 - ON DELETE SET NULL : 외래키의 참조하는곳이 삭제되면 NULL로 둬라
 - ON DELETE SET DEFAULT : 외래키의 참조하는곳이 삭제되면 DEFAULT로 설정

데이터 조작어
 - 실렉션, 프로젝션, 조인, 카티션 곱 등을 결합한것
 - SELECT, FROM, WHERE































